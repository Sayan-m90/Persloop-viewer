

/***********************************************/
char strLicense[] = "THIS SOFTWARE IS PROVIDED \"AS-IS\". THERE IS NO WARRANTY OF ANY KIND. "
"NEITHER THE AUTHORS NOR THE OHIO STATE UNIVERSITY WILL BE LIABLE FOR "
"ANY DAMAGES OF ANY KIND, EVEN IF ADVISED OF SUCH POSSIBILITY. \n"
"\n"
"This software was developed (and is copyrighted by) the Jyamiti group at "
"The Ohio State University. Please do not redistribute this software. "
"This program is for academic research use only. This software uses the "
"Boost library (www.boost.org) "
"which is covered under their own licenses.\n"
"\n"
"The Boost library's license "
"(which applies to the Boost library ONLY and NOT to this program itself) is "
"as follows:\n"
"\n"
"LICENSE\n"
"---------------------------------------------------------------------------\n"
"Boost Software License - Version 1.0 - August 17th, 2003\n"
"\n"
"Permission is hereby granted, free of charge, to any person or organization "
"obtaining a copy of the software and accompanying documentation covered by "
"this license (the \"Software\") to use, reproduce, display, distribute, "
"execute, and transmit the Software, and to prepare derivative works of the "
"Software, and to permit third-parties to whom the Software is furnished to "
"do so, all subject to the following: \n"
"\n"
"The copyright notices in the Software and this entire statement, including "
"the above license grant, this restriction and the following disclaimer, "
"must be included in all copies of the Software, in whole or in part, and "
"all derivative works of the Software, unless such copies or derivative "
"works are solely in the form of machine-executable object code generated by "
"a source language processor. \n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR "
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, "
"FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT "
"SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE "
"FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, "
"ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER "
"DEALINGS IN THE SOFTWARE. \n"
"---------------------------------------------------------------------------\n";
/**********************************************************************/



bool ParseCommand(int argc, char** argv, int &bars, std::string &filtration_file){
	try
	{
		/* Define the program options description
		*/
		namespace po = boost::program_options;
		po::options_description desc("loopGeom Usage");
		desc.add_options()
			(",h", "Help information;")
			(",l", "License information;")
//			(",c", po::value<double>(&sampling_coefficient)->default_value(0.95), "Sampling coefficient")
			//(",i", po::value<std::string>(&input_pointcloud_file)->default_value(""), "The file name for the initial point cloud")
			//(",r", po::value<std::string>(&output_file)->default_value(""), "The file name containing killed output loop")
//			(",b", po::value<int>(&barcodes)->default_value(20), "No of barcodes for OFF. ")
            (",n", po::value<int>(&bars)->default_value(10), "The number of top barcodes to generate 1-cycle")
        (",f", po::value<std::string>(&filtration_file)->default_value(""), "The file contains filtration and points after input");
//        (",d", po::value<int>(&dimension)->default_value(3), "Dimension of point cloud");
			
			//(",s", po::value<std::string>(&output_persistence_file_name)->default_value("pers"), "The file name for the output 				persistence barcodes of input simplicial maps (default value: \"pers\")");
		// Parser map
		po::variables_map vm;
		try
		{
			po::store(po::parse_command_line(argc, argv, desc), vm);

			//
			if (vm.count("-h"))
			{
				std::cout << desc << std::endl;
				exit(EXIT_SUCCESS);
			}
			//
			if (vm.count("-l"))
			{
				std::cout << strLicense << std::endl;
				exit(EXIT_SUCCESS);
			}
			//
			po::notify(vm);
		}
		catch (boost::program_options::required_option& i)
		{
			std::cerr << "ERROR: " << i.what() << std::endl;
			return false;
		}
		catch (boost::program_options::error& i)
		{
			std::cerr << "ERROR: " << i.what() << std::endl;
			return false;
		}
	}
	catch (std::exception& i)
	{
		std::cerr << "Unhandled Exception reached the top of main: "
			<< i.what() << ", application will now exit" << std::endl;
		return false;

	}
	return true;
}	//end ParseCommand
